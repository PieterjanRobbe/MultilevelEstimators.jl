<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · MultilevelEstimators.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="MultilevelEstimators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">MultilevelEstimators.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="example.html">Example</a></li><li class="is-active"><a class="tocitem" href="manual.html">Manual</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#IndexSet"><span>IndexSet</span></a></li><li><a class="tocitem" href="#SampleMethod"><span>SampleMethod</span></a></li><li><a class="tocitem" href="#Distribution"><span>Distribution</span></a></li><li><a class="tocitem" href="#LatticeRule32"><span>LatticeRule32</span></a></li><li><a class="tocitem" href="#Estimator"><span>Estimator</span></a></li><li><a class="tocitem" href="#History"><span>History</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="manual.html">Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="manual.html">Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/master/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><ul><li><a href="manual.html#Manual">Manual</a></li><ul><li><a href="manual.html#Index">Index</a></li><li><a href="manual.html#IndexSet">IndexSet</a></li><li><a href="manual.html#SampleMethod">SampleMethod</a></li><li><a href="manual.html#Distribution">Distribution</a></li><li><a href="manual.html#LatticeRule32">LatticeRule32</a></li><li><a href="manual.html#Estimator">Estimator</a></li><li><a href="manual.html#History">History</a></li></ul></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.Level" href="#MultilevelEstimators.Level"><code>MultilevelEstimators.Level</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Level(l::Integer)</code></pre><p>Return a level.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; level = Level(2)
2</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.Index"><code>Index</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.Index" href="#MultilevelEstimators.Index"><code>MultilevelEstimators.Index</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Index(i::Integer...)</code></pre><p>Return a multi-index.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; index = Index(2, 1)
(2, 1)</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.Level"><code>Level</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index.jl#L9-L20">source</a></section></article><h2 id="IndexSet"><a class="docs-heading-anchor" href="#IndexSet">IndexSet</a><a id="IndexSet-1"></a><a class="docs-heading-anchor-permalink" href="#IndexSet" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.SL" href="#MultilevelEstimators.SL"><code>MultilevelEstimators.SL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SL()</code></pre><p>Return a single-level index set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SL()
SL</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.ML"><code>ML</code></a>, <a href="manual.html#MultilevelEstimators.FT"><code>FT</code></a>, <a href="manual.html#MultilevelEstimators.TD"><code>TD</code></a>, <a href="manual.html#MultilevelEstimators.HC"><code>HC</code></a>, <a href="manual.html#MultilevelEstimators.ZC"><code>ZC</code></a>, <a href="manual.html#MultilevelEstimators.AD"><code>AD</code></a>, <a href="manual.html#MultilevelEstimators.U"><code>U</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index_set.jl#L14-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.ML" href="#MultilevelEstimators.ML"><code>MultilevelEstimators.ML</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ML()</code></pre><p>Return a multi-level index set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ML()
ML</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.SL"><code>SL</code></a>, <a href="manual.html#MultilevelEstimators.FT"><code>FT</code></a>, <a href="manual.html#MultilevelEstimators.TD"><code>TD</code></a>, <a href="manual.html#MultilevelEstimators.HC"><code>HC</code></a>, <a href="manual.html#MultilevelEstimators.ZC"><code>ZC</code></a>, <a href="manual.html#MultilevelEstimators.AD"><code>AD</code></a>, <a href="manual.html#MultilevelEstimators.U"><code>U</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index_set.jl#L33-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.FT" href="#MultilevelEstimators.FT"><code>MultilevelEstimators.FT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FT(d::Integer)
FT(δ::Real...)
FT(δ::AbstractVector{&lt;:Real})
FT(δ::NTuple{N, &lt;:Real})</code></pre><p>Return a full tensor index set in <code>d</code> dimenions with optional weights <code>δ</code>. Default weights are all 1&#39;s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; FT(2)
FT{2}

julia&gt; FT([1, 1/2, 1/2])
FT{3}

julia&gt; print(FT(2), 4)
  ◼ ◼ ◼ ◼ ◼
  ◼ ◼ ◼ ◼ ◼
  ◼ ◼ ◼ ◼ ◼
  ◼ ◼ ◼ ◼ ◼
  ◼ ◼ ◼ ◼ ◼</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.SL"><code>SL</code></a>, <a href="manual.html#MultilevelEstimators.ML"><code>ML</code></a>, <a href="manual.html#MultilevelEstimators.TD"><code>TD</code></a>, <a href="manual.html#MultilevelEstimators.HC"><code>HC</code></a>, <a href="manual.html#MultilevelEstimators.ZC"><code>ZC</code></a>, <a href="manual.html#MultilevelEstimators.AD"><code>AD</code></a>, <a href="manual.html#MultilevelEstimators.U"><code>U</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index_set.jl#L52-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.TD" href="#MultilevelEstimators.TD"><code>MultilevelEstimators.TD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TD(d::Integer)
TD(δ::Real...)
TD(δ::AbstractVector{&lt;:Real})
TD(δ::NTuple{N, &lt;:Real})</code></pre><p>Return a total degree index set in <code>d</code> dimenions with optional weights <code>δ</code>. Default weights are all 1&#39;s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; TD(2)
TD{2}

julia&gt; TD([1, 1/2, 1/2])
TD{3}

julia&gt; print(TD(2), 4)
  ◼
  ◼ ◼
  ◼ ◼ ◼
  ◼ ◼ ◼ ◼
  ◼ ◼ ◼ ◼ ◼</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.SL"><code>SL</code></a>, <a href="manual.html#MultilevelEstimators.ML"><code>ML</code></a>, <a href="manual.html#MultilevelEstimators.FT"><code>FT</code></a>, <a href="manual.html#MultilevelEstimators.HC"><code>HC</code></a>, <a href="manual.html#MultilevelEstimators.ZC"><code>ZC</code></a>, <a href="manual.html#MultilevelEstimators.AD"><code>AD</code></a>, <a href="manual.html#MultilevelEstimators.U"><code>U</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index_set.jl#L84-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.HC" href="#MultilevelEstimators.HC"><code>MultilevelEstimators.HC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HC(d::Integer)
HC(δ::Real...)
HC(δ::AbstractVector{&lt;:Real})
HC(δ::NTuple{N, &lt;:Real})</code></pre><p>Return a hyperbolic cross index set in <code>d</code> dimenions with optional weights <code>δ</code>. Default weights are all 1&#39;s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HC(2)
HC{2}

julia&gt; HC([1, 1/2, 1/2])
HC{3}

julia&gt; print(HC(2), 4)
  ◼
  ◼
  ◼
  ◼ ◼
  ◼ ◼ ◼ ◼ ◼</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.SL"><code>SL</code></a>, <a href="manual.html#MultilevelEstimators.ML"><code>ML</code></a>, <a href="manual.html#MultilevelEstimators.FT"><code>FT</code></a>, <a href="manual.html#MultilevelEstimators.TD"><code>TD</code></a>, <a href="manual.html#MultilevelEstimators.ZC"><code>ZC</code></a>, <a href="manual.html#MultilevelEstimators.AD"><code>AD</code></a>, <a href="manual.html#MultilevelEstimators.U"><code>U</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index_set.jl#L117-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.ZC" href="#MultilevelEstimators.ZC"><code>MultilevelEstimators.ZC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ZC(d::Integer)
ZC(δ::Real...)
ZC(δ::AbstractVector{&lt;:Real})
ZC(δ::NTuple{N, &lt;:Real})</code></pre><p>Return a Zaremba cross index set in <code>d</code> dimenions with optional weights <code>δ</code>. Default weights are all 1&#39;s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ZC(2)
ZC{2}

julia&gt; ZC([1, 1/2, 1/2])
ZC{3}

julia&gt; print(ZC(2), 4)
  ◼ ◼ 
  ◼ ◼ 
  ◼ ◼ ◼ 
  ◼ ◼ ◼ ◼ ◼ 
  ◼ ◼ ◼ ◼ ◼ </code></pre><p>See also: <a href="manual.html#MultilevelEstimators.SL"><code>SL</code></a>, <a href="manual.html#MultilevelEstimators.ML"><code>ML</code></a>, <a href="manual.html#MultilevelEstimators.FT"><code>FT</code></a>, <a href="manual.html#MultilevelEstimators.TD"><code>TD</code></a>, <a href="manual.html#MultilevelEstimators.HC"><code>HC</code></a>, <a href="manual.html#MultilevelEstimators.AD"><code>AD</code></a>, <a href="manual.html#MultilevelEstimators.U"><code>U</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index_set.jl#L150-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.AD" href="#MultilevelEstimators.AD"><code>MultilevelEstimators.AD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AD(d::Integer)</code></pre><p>Return an adaptive index set in <code>d</code> dimenions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; AD(2)
AD{2}</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.SL"><code>SL</code></a>, <a href="manual.html#MultilevelEstimators.ML"><code>ML</code></a>, <a href="manual.html#MultilevelEstimators.FT"><code>FT</code></a>, <a href="manual.html#MultilevelEstimators.TD"><code>TD</code></a>, <a href="manual.html#MultilevelEstimators.HC"><code>HC</code></a>, <a href="manual.html#MultilevelEstimators.ZC"><code>ZC</code></a>, <a href="manual.html#MultilevelEstimators.U"><code>U</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index_set.jl#L196-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.U" href="#MultilevelEstimators.U"><code>MultilevelEstimators.U</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">U(d::Integer)</code></pre><p>Return an unbiased  multi-level or multi-index index set in <code>d</code> dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; U(2)
U{2}</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.SL"><code>SL</code></a>, <a href="manual.html#MultilevelEstimators.ML"><code>ML</code></a>, <a href="manual.html#MultilevelEstimators.FT"><code>FT</code></a>, <a href="manual.html#MultilevelEstimators.TD"><code>TD</code></a>, <a href="manual.html#MultilevelEstimators.HC"><code>HC</code></a>, <a href="manual.html#MultilevelEstimators.ZC"><code>ZC</code></a>, <a href="manual.html#MultilevelEstimators.AD"><code>AD</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index_set.jl#L213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.get_index_set" href="#MultilevelEstimators.get_index_set"><code>MultilevelEstimators.get_index_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_index_set(idxset::AbstractIndexSet, sz::Integer)</code></pre><p>Return an iterator over all indices in the index set <code>idxset</code> for a given size parameter <code>sz</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; collect(get_index_set(TD(2), 2))
6-element Array{CartesianIndex{2},1}:
 (0, 0)
 (1, 0)
 (2, 0)
 (0, 1)
 (1, 1)
 (0, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index_set.jl#L240-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print" href="#Base.print"><code>Base.print</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">print(idxset::AbstractIndexSet{2}, sz::Integer)</code></pre><p>Print the indices in the index set <code>idxset</code> for a given size parameter <code>sz</code>. Only implemented for two-dimensional index sets.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; print(TD(2), 3)
  ◼
  ◼ ◼
  ◼ ◼ ◼
  ◼ ◼ ◼ ◼</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/index_set.jl#L280-L293">source</a></section></article><h2 id="SampleMethod"><a class="docs-heading-anchor" href="#SampleMethod">SampleMethod</a><a id="SampleMethod-1"></a><a class="docs-heading-anchor-permalink" href="#SampleMethod" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.MC" href="#MultilevelEstimators.MC"><code>MultilevelEstimators.MC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MC()</code></pre><p>Return a Monte Carlo sample method.</p><p>See also: <a href="manual.html#MultilevelEstimators.QMC"><code>QMC</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/sample_method.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.QMC" href="#MultilevelEstimators.QMC"><code>MultilevelEstimators.QMC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QMC()</code></pre><p>Return a Quasi-Monte Carlo sample method.</p><p>See also: <a href="manual.html#MultilevelEstimators.MC"><code>MC</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/sample_method.jl#L21-L27">source</a></section></article><h2 id="Distribution"><a class="docs-heading-anchor" href="#Distribution">Distribution</a><a id="Distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Distribution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.Uniform" href="#MultilevelEstimators.Uniform"><code>MultilevelEstimators.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Uniform([a = 0, [b = 1]])</code></pre><p>Return a uniform distribution on [<code>a</code>, <code>b</code>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Uniform()
Uniform{Int64}(a = 0, b = 1)</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.Normal"><code>Normal</code></a>, <a href="manual.html#MultilevelEstimators.TruncatedNormal"><code>TruncatedNormal</code></a>, <a href="manual.html#MultilevelEstimators.Weibull"><code>Weibull</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/distribution.jl#L19-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.Normal" href="#MultilevelEstimators.Normal"><code>MultilevelEstimators.Normal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Normal([μ = 0, [σ = 1]])</code></pre><p>Return a normal distribution with mean <code>μ</code> and standard deviation <code>σ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Normal()
Normal{Int64}(μ = 0, σ = 1)</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.Uniform"><code>Uniform</code></a>, <a href="manual.html#MultilevelEstimators.TruncatedNormal"><code>TruncatedNormal</code></a>, <a href="manual.html#MultilevelEstimators.Weibull"><code>Weibull</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/distribution.jl#L87-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.TruncatedNormal" href="#MultilevelEstimators.TruncatedNormal"><code>MultilevelEstimators.TruncatedNormal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TruncatedNormal([μ = 0, [σ = 1, [a = -2, [b = 2]]]])</code></pre><p>Return a truncated normal distribution with mean <code>μ</code> and standard deviation <code>σ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; TruncatedNormal()
TruncatedNormal{Int64}(μ = 0, σ = 1, a = -2, b = 2)</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.Uniform"><code>Uniform</code></a>, <a href="manual.html#MultilevelEstimators.Normal"><code>Normal</code></a>, <a href="manual.html#MultilevelEstimators.Weibull"><code>Weibull</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/distribution.jl#L115-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.Weibull" href="#MultilevelEstimators.Weibull"><code>MultilevelEstimators.Weibull</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Weibull([k = 2, [λ = √2]])</code></pre><p>Return a Weibull distribution with shape parameter <code>k</code> and scale parameter <code>λ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Weibull()
Weibull{Float64}(k = 2.0, λ = 1.4142135623730951)</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.Uniform"><code>Uniform</code></a>, <a href="manual.html#MultilevelEstimators.Normal"><code>Normal</code></a>, <a href="manual.html#MultilevelEstimators.TruncatedNormal"><code>TruncatedNormal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/distribution.jl#L156-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.transform" href="#MultilevelEstimators.transform"><code>MultilevelEstimators.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform(D::AbstractDistribution, x::Real)</code></pre><p>Apply a transformation to the uniformly distributed number <code>x</code> such that it is distributed according to <code>D</code>.</p><p>The transform is implemented by applying the inverse CDF of the distribution <code>D</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is currently limited only to distributions with an analytic expression for the inverse CDF.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = rand(10)
10-element Array{Float64,1}:
 0.23603334566204692
 0.34651701419196046
 0.3127069683360675
 0.00790928339056074
 0.4886128300795012
 0.21096820215853596
 0.951916339835734
 0.9999046588986136
 0.25166218303197185
 0.9866663668987996

julia&gt; broadcast(i -&gt; transform(Normal(), i), x)
10-element Array{Float64,1}:
 -0.7191204773101185 
 -0.39474101736576256
 -0.4881918784059056 
 -2.413074939355834  
 -0.02854727903738184
 -0.8030663180302484 
  1.6637253880181684 
  3.7310515426407296 
 -0.6692682660790877 
  2.2163540181904553 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/distribution.jl#L44-L83">source</a></section></article><h2 id="LatticeRule32"><a class="docs-heading-anchor" href="#LatticeRule32">LatticeRule32</a><a id="LatticeRule32-1"></a><a class="docs-heading-anchor-permalink" href="#LatticeRule32" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.LatticeRule32" href="#MultilevelEstimators.LatticeRule32"><code>MultilevelEstimators.LatticeRule32</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LatticeRule32(z, s, n)
LatticeRule32(z, s)
LatticeRule32(z)</code></pre><p>Returns a rank-1 lattice rule in <code>s</code> dimensions with generating vector <code>z</code> and at most <code>n</code> points.</p><p>When no maximum number of points <code>n</code> is provided, we assume <code>n=2^32</code>. When no number of dimensions <code>s</code> is provided, we assume <code>s=length(z)</code>. </p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Technically, we return an extensible lattice sequence where the <code>k</code>-th point is transformed using the radical inverse function. This has the advantage that we can add points to the set without changing the already computed points.</p></div></div><p>More generating vectors can be found online <a href="https://web.maths.unsw.edu.au/~fkuo/lattice/index.html">here</a> or <a href="https://people.cs.kuleuven.be/~dirk.nuyens/qmc-generators/">here</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lattice_rule = LatticeRule32([0x00000001,0x00000022], 2, 0x00000037) # Fibonacci lattice rule
LatticeRule32{2}

julia&gt; get_point(lattice_rule, 2)
2-element Array{Float64,1}:
 0.75
 0.5

julia&gt; get_point(lattice_rule, 56) # returns random points beyond n
2-element Array{Float64,1}:
 0.23603334566204692
 0.34651701419196046</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.get_point"><code>get_point</code></a>, <a href="manual.html#MultilevelEstimators.ShiftedLatticeRule"><code>ShiftedLatticeRule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/lattice.jl#L16-L47">source</a></section><section><div><pre><code class="language-none">LatticeRule32(str, s, n)
LatticeRule32(str, s)
LatticeRule32(str)</code></pre><p>Returns a rank-1 lattice rule in <code>s</code> dimensions with generating vector <code>z</code> read from the file <code>str</code> and at most <code>n</code> points.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; z_file = joinpath(dirname(pathof(MultilevelEstimators)), &quot;generating_vectors&quot;, &quot;K_3600_32.txt&quot;);

julia&gt; lattice_rule = LatticeRule32(z_file, 16)
LatticeRule32{16}

julia&gt; get_point(lattice_rule, 123)
16-element Array{Float64,1}:
 0.3828125
 0.2890625
 0.1484375
 0.3515625
 0.6015625
 0.1171875
 0.4296875
 0.4609375
 0.2265625
 0.6484375
 0.9609375
 0.6796875
 0.0546875
 0.2265625
 0.1328125
 0.1640625
</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.get_point"><code>get_point</code></a>, <a href="manual.html#MultilevelEstimators.ShiftedLatticeRule"><code>ShiftedLatticeRule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/lattice.jl#L52-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.ShiftedLatticeRule" href="#MultilevelEstimators.ShiftedLatticeRule"><code>MultilevelEstimators.ShiftedLatticeRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ShiftedLatticeRule(lat::AbstractLatticeRule)</code></pre><p>Returns a shifted rank-1 lattice rule based on the lattice rule <code>lat</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; z_file = joinpath(dirname(pathof(MultilevelEstimators)), &quot;generating_vectors&quot;, &quot;K_3600_32.txt&quot;);

julia&gt; lattice_rule = LatticeRule32(z_file, 16)
LatticeRule32{16}

julia&gt; shifted_lattice_rule = ShiftedLatticeRule(lattice_rule)
ShiftedLatticeRule{LatticeRule32{16}}

julia&gt; get_point(shifted_lattice_rule, 0)
16-element Array{Float64,1}:
 0.23603334566204692
 0.34651701419196046
 0.3127069683360675
 0.00790928339056074
 0.4886128300795012
 0.21096820215853596
 0.951916339835734
 0.9999046588986136
 0.25166218303197185
 0.9866663668987996
 0.5557510873245723
 0.43710797460962514
 0.42471785049513144
 0.773223048457377
 0.2811902322857298
 0.20947237319807077
</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.LatticeRule32"><code>LatticeRule32</code></a>, <a href="manual.html#MultilevelEstimators.get_point"><code>get_point</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/lattice.jl#L95-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.get_point" href="#MultilevelEstimators.get_point"><code>MultilevelEstimators.get_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_point(lat::AbstractLatticeRule, k::Integer)</code></pre><p>Get the <code>k</code>-th point of the lattice rule <code>lat</code>.</p><pre><code class="language-julia-repl">julia&gt; lattice_rule = LatticeRule32([0x00000001,0x00000022], 2, 0x00000037) # Fibonacci lattice rule
LatticeRule32{2}

julia&gt; get_point(lattice_rule, 2)
2-element Array{Float64,1}:
 0.75
 0.5
</code></pre><p>See also: <a href="manual.html#MultilevelEstimators.LatticeRule32"><code>LatticeRule32</code></a>, <a href="manual.html#MultilevelEstimators.ShiftedLatticeRule"><code>ShiftedLatticeRule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/lattice.jl#L147-L163">source</a></section></article><h2 id="Estimator"><a class="docs-heading-anchor" href="#Estimator">Estimator</a><a id="Estimator-1"></a><a class="docs-heading-anchor-permalink" href="#Estimator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.Estimator" href="#MultilevelEstimators.Estimator"><code>MultilevelEstimators.Estimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Estimator(index_set::AbstractIndexSet,
          sample_method::AbstractSampleMethod,
          sample_function::Function,
          distributions::Vector{&lt;:Distribution}; kwargs...)</code></pre><p>Create an <code>Estimator</code> with index set <code>index_set</code> and sample method <code>sample_method</code> to compute the expected value of the quantity of interest returned by <code>sample_function</code>, and where <code>distributions</code> is the uncertainty on the input parameters.</p><p><strong>Examples</strong></p><p>See the <a href="example.html#Example">example section in the online documentation</a> for examples on how to use this function.</p><p><strong>General keywords</strong></p><p>Different algorithmic options can be set by providing appropriate keyword arguments. A list of these keyword arguments and their description is provided below.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Not all keyword arguments can be used in combination with all <code>Estimator</code> types.</p></div></div><p><strong><code>name</code></strong> – a human readable name for the problem that must be solved. This name will be used when saving a <a href="manual.html#MultilevelEstimators.History"><code>History</code></a> file with diagnostic information from each <a href="manual.html#Base.run"><code>run</code></a>, and also when generating reports with the <a href="https://github.com/PieterjanRobbe/Reporter.jl"><code>Reporter</code></a>-package. Default is <code>UntitledEstimator</code>.</p><p><strong><code>folder</code></strong> is where the <a href="manual.html#MultilevelEstimators.History"><code>History</code></a> files with diagnostic information from every <a href="manual.html#Base.run"><code>run</code></a> will be saved. Default is the current directory.</p><p><strong><code>save</code></strong> – if set to <code>true</code>, MultilevelEstimators saves diagnostic information about the simulation in a separate file in the <code>.jld2</code> format. See <a href="https://github.com/JuliaIO/JLD2.jl"><code>JLD2</code></a> for more information about this file format. By default, this keyword is set to <code>true</code>.</p><p><strong><code>verbose</code></strong> – if set to <code>true</code>, MultilevelEstimators will print useful information about the <a href="manual.html#Base.run"><code>run</code></a> to <code>STDOUT</code>. Default is <code>true</code>.</p><p><strong><code>nb_of_warm_up_samples</code></strong> is the number of warm-up samples to take at each level (or index) to obtain initial variance estimates. In combination with <code>do_regression = true</code> (default), this is only true for all levels &lt; 2 (or indices with all coordinate directions &lt; 2). On all other levels (or indices), this is the initial maximum number of regressed samples. When using <a href="manual.html#MultilevelEstimators.MC"><code>MC</code></a>-sampling, this value must be larger than or equal to 2, in order to be able to compute the variance. The default value is 20. When using <a href="manual.html#MultilevelEstimators.QMC"><code>QMC</code></a>-sampling, this is the number of samples per random shift, and since we only consider the variance with repect to all random shifts, this value can be as small as 1 (default). Increase this number for more accurate initial variance estimation.   </p><p><strong><code>nb_of_qoi</code></strong> is the number of quantities of interest returned by the <code>sample_function</code>. In this case, the simulation will be performed by controlling the root mean square error of the quantity of interest with the largest variance. The expected value of all other quantities of interest is guaranteed to be estimated more accurate or as accurate as the one with the largest variance. The default value is 1. The quantitiy of interest can optionally be provided using the key <code>qoi_with_max_var</code>, te ensure that the same quantity is used in every iteration. </p><p><strong><code>continuate</code></strong> – if set to <code>true</code>, each call to <a href="manual.html#Base.run"><code>run</code></a> with a specified tolerance <code>tol</code> results in a simulation for a sequence of larger tolerances <span>$\text{tol}_i = p^{(n-1-i)} \text{tol}$</span> to get improved estimates for the variance and the bias. The default value is <code>true</code>.</p><p><strong><code>continuation_mul_factor</code></strong> is the value <span>$p$</span> in the above formula. The default value is 1.2.</p><p><strong><code>nb_of_tols</code></strong> is the value <span>$n$</span> in the above formula. The default value is 10.</p><p><strong><code>save_samples</code></strong> – if set to <code>true</code>, all samples of a <a href="manual.html#Base.run"><code>run</code></a> will be saved together with the diagnostic information. This is usefull for plotting histograms etc.</p><p><strong><code>cost_model</code></strong> allows the user to provide a function that returns the cost of a sample on each index. For example, a geometric cost model could be provided with</p><pre><code class="language-julia">γ = 1.5
Estimator(...; cost_model = level -&gt; 2^(γ * level[1]))</code></pre><p>When no cost model is provided (default), the actual run time on each level (or index) is used as a proxy for the cost model.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Beware of precompilation! Using actual run times for the cost model might be very unreliable, especially on the coarsest level (or index), when the <a href="manual.html#MultilevelEstimators.Estimator"><code>Estimator</code></a> is <a href="manual.html#Base.run"><code>run</code></a> for the first time. In real production code, it is advised that the <code>run</code>-function is called once beforehand with a larger tolerance than the target accuracuy, to eliminate precompilation time.</p><pre><code class="language-julia">run(estimator, 10 * tol) # precompilation run
run(estimator, tol)</code></pre></div></div><p><strong><code>nb_of_workers</code></strong> allows the user to specify the number of workers (processors) to be used for parallel sampling in a multicore environment. By default, this is equal to the value returned by <code>nworkers()</code>. <code>nb_of_workers</code> can also be given as function, specifying the number of workers on each level (or index). This is particularly usefull for expensive sample functions that require non-trivial load balancing.</p><p><strong><code>nb_of_uncertainties</code></strong> is a function indicating the number of uncertainties to be used on each level (or each index). The default value is equal to the length of <code>distributions</code>, the vector of <a href="manual.html#Distribution"><code>Distribution</code></a>s specifying the input uncertainty of the parameters. This is useful for so-called level-dependent estimators, where a different number of parameters is activated on each level (or index). The length of <code>distributions</code> must be larger than or equal to the maximum value returned by this function.</p><p><strong><code>max_index_set_param</code></strong> is the maximum index set size parameter that can be used in a simulation. Typically, a simulation will only be possible up to a finite index set size parameter, due to, for instance, memory constraints or prohibitively lare computational cost. For a multilevel simulation with <a href="manual.html#MultilevelEstimators.ML"><code>ML</code></a> this is the maximum number of levels. For a multi-index simulation with <a href="manual.html#MultilevelEstimators.FT"><code>FT</code></a>, <a href="manual.html#MultilevelEstimators.TD"><code>TD</code></a>, <a href="manual.html#MultilevelEstimators.HC"><code>HC</code></a> or <a href="manual.html#MultilevelEstimators.ZC"><code>ZC</code></a>, this is the maximum index set size parameter. For simulations with <a href="manual.html#MultilevelEstimators.AD"><code>AD</code></a> or <a href="manual.html#MultilevelEstimators.U"><code>U</code></a>, this is the maximum index set size to be used in the <code>max_search_space</code> (see below). Default is 10 times the number of dimensions of the index set. When this value is exceeded, the simulation will stop with a bias (and, consequently, a root mean square error) larger than the requested accuracy.</p><p><strong><code>min_index_set_param</code></strong> is the minimum index set size parameter that should be used in a simulation. Useful for providing a minimum number of levels that should be used. This parameter should be at least 2 to allow for regression and estimation of the rates <code>alpha</code> and `beta. Default value is 2.</p><p><strong>Keywords valid for index set types <a href="manual.html#MultilevelEstimators.SL"><code>SL</code></a>, <a href="manual.html#MultilevelEstimators.ML"><code>ML</code></a>, <a href="manual.html#MultilevelEstimators.FT"><code>FT</code></a>, <a href="manual.html#MultilevelEstimators.TD"><code>TD</code></a>, <a href="manual.html#MultilevelEstimators.HC"><code>HC</code></a> and <a href="manual.html#MultilevelEstimators.ZC"><code>ZC</code></a></strong></p><p><strong><code>do_regression</code></strong> – if set to <code>true</code>, the variance on the finer levels (or indices) will be guessed from the aready available variances on the coarser levels (or indices). These finer levels (or indices) must have a value larger than or equal to 2 in at least one of the coordinate directions. This is very powerfull when dealing with computationally demanding sample functions. Default: <code>true</code>.</p><p><strong><code>do_mse_splitting</code></strong> – if set to <code>true</code>, MultilevelEstimators will use a non-trivial splitting of the mean square error of the estimator: <span>$\text{MSE} = \theta \text{var} + (1 - \theta) \text{bias}^2$</span>. The value of the splitting parameter is very important to obtain an efficient estimator. Default is <code>true</code>.  </p><p><strong><code>min_splitting</code></strong> is the minimum value for the mean square error splitting parameter. Default: 0.5.</p><p><strong><code>max_splitting</code></strong> is the maximum value for the mean square error splitting parameter. Default: 0.99.</p><p><strong>Keywords valid for index set types <a href="manual.html#MultilevelEstimators.AD"><code>AD</code></a> and <a href="manual.html#MultilevelEstimators.U"><code>U</code></a></strong></p><p><strong><code>max_search_space</code></strong> determines, together with <code>max_index_set_param</code>, the collection of all indices that may be considered for further refinement. This is necessary for <code>AD</code>- and <code>U</code>-type index sets, that do not define such a set, by defintion. Default: TD.  </p><p><strong>Keywords valid for <a href="manual.html#MultilevelEstimators.AD"><code>AD</code></a> index sets</strong></p><p><strong><code>penalization</code></strong> is a factor added to the computation of the profit indicators in the adaptive algorithm. We observed that in some cases, the algorithm stretches its search space too much around the coordinate axes, especially when actual computation times are used (see <code>cost_model</code>). The penalization parameter 0&lt;<code>p</code>&lt;1 penalizes these search directions, in favor of more classically-shaped index sets, such as <a href="manual.html#MultilevelEstimators.TD"><code>TD</code></a>.</p><p class="math-container">\[P_\ell = \frac{E_\ell}{(\sqrt{V_\ell W_\ell})^p}\]</p><p><strong><code>accept_rate</code></strong> is the acceptance rate in the accept-reject method for chosing new indices from the active set for further refinement. A lower value means a more global search stretegy. Usefull when the adaptive method finds itself stuck along a single coordinate direction. Default value is 1 (no accept-reject).</p><p><strong>Keywords valid for <a href="manual.html#MultilevelEstimators.QMC"><code>QMC</code></a> sample methods</strong></p><p><strong><code>nb_of_shifts</code></strong> indicates the number of randomly-shifted rank-1 lattice rules used in the <a href="manual.html#MultilevelEstimators.QMC"><code>QMC</code></a> method. The higher this value, the more accurate the variance estimation will be. This keyword can also be a function that returns the number of shifts on each level (or index). Typically, the number of shifts on coarser levels will be smaller than the number of shifts on finer levels, since, on these coarse levels, many QMC samples will be available. Default is 10 random shifts.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We recommend a value for <code>nb_of_shifts</code> between 10 and 30.</p></div></div><p><strong><code>sample_mul_factor</code></strong> is the multplication factor in the QMC &quot;doubling algorithm&quot;. Typically, and as can be justified theoretically, this value is equal to 2. We find that it is sometimes more beneficial to use a smaller multiplication factor, since direclty doubling the number of samples is a quite dramatic event. Default: 1.2.</p><p><strong><code>point_generator</code></strong> is a keyword that allows the user to specify a custom QMC point set of type <code>AbstractLatticeRule</code>. Default is a 3600-dimensional lattice rule from <a href="https://web.maths.unsw.edu.au/~fkuo/lattice/index.html">this website</a>. </p><p>See also: <a href="manual.html#Base.run"><code>run</code></a>, <a href="manual.html#MultilevelEstimators.History"><code>History</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/estimator.jl#L9-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.run" href="#Base.run"><code>Base.run</code></a> — <span class="docstring-category">Function</span></header><section><div><p>run(estimator::Estimator, ε::Real) run(estimator::Estimator, ε::Vector{&lt;:Real})</p><p>Run the estimator and compute the expected value of the quantity of interest up to the given tolerance(s) <code>ε</code>. Returns a <a href="manual.html#MultilevelEstimators.History"><code>History</code></a>-object that contains usefull diagnostics about the simulation. </p><p><strong>Examples</strong></p><p>An example detailing how to use MultilevelEstimators is provided in the <a href="example.html#Example">example in the documentation</a>.</p><p>See also: <a href="manual.html#MultilevelEstimators.Estimator"><code>Estimator</code></a>, <a href="manual.html#MultilevelEstimators.History"><code>History</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/run.jl#L8-L19">source</a></section></article><h2 id="History"><a class="docs-heading-anchor" href="#History">History</a><a id="History-1"></a><a class="docs-heading-anchor-permalink" href="#History" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultilevelEstimators.History" href="#MultilevelEstimators.History"><code>MultilevelEstimators.History</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">History</code></pre><p>A History is the result of a call to <a href="manual.html#Base.run"><code>run</code></a> and contains useful diagnostic information about the state of the <code>Estimator</code>.</p><p>The information is stored as a <code>Vector</code> of <code>Dict</code>&#39;s, where each entry in the vector is the result of a single run. See below for a list of keys added to these <code>Dict</code>s. Access to the key corresponding to the last entry in the <code>History</code> (that is, the one with the highest accuracy) is provided as <code>history[key]</code>.</p><p>See also the package <a href="https://github.com/PieterjanRobbe/Reporter.jl"><code>Reporter</code></a> for automatic generation of reports based on a History object.</p><p><strong>Keys</strong></p><ul><li><code>type::AbstractIndexSet</code>: the index set type of the <code>Estimator</code>.</li><li><code>ndims::Integer</code>: the number of dimensions of the <code>Estimator</code>.</li><li><code>name::String</code>: the name of this <code>Estimator</code>.</li><li><code>folder::String</code>: the directory where the results are stored.</li><li><code>elapsed::Real</code>: the elapsed time (in seconds).</li><li><code>tol::Real</code>: the request accuracy.</li><li><code>current_index_set::Vector{::Index}</code>: the levels (or indices) currently in use by the <code>Estimator</code>.</li><li><code>index_set::Vector{::Index}</code>: all levels (or indices) that are added to the <code>Estimator</code>.</li><li><code>mse::Real</code>: the measured mean square error of the <code>Estimator</code>. </li><li><code>rmse::Real</code>: the measured root mean square error of the <code>Estimator</code>. </li><li><code>mean::Real</code>: the estimated expected value of the quantity of interest, up to an absolute error of <code>tol</code>.</li><li><code>var::Real</code>: the measured variance of the quantity of interest.</li><li><code>varest::Real</code>: the measured variance of the <code>Estimator</code> for the expected value of the quantity of interest.</li><li><code>bias::Real</code>: the measured bias of the <code>Estimator</code>.</li><li><code>E::Dict{::Index, ::Real}</code>: a <code>Dict</code> with the measured expected value of the quantity of interest on each level (or index).</li><li><code>V::Dict{::Index, ::Real}</code>: a <code>Dict</code> with the measured variance of the quantity of interest on each level (or index).</li><li><code>dE::Dict{::Index, ::Real}</code>: a <code>Dict</code> with the measured expected value of the <strong>difference</strong> of the quantity of interest on each level (or index).</li><li><code>dV::Dict{::Index, ::Real}</code>: a <code>Dict</code> with the measured variance of the <strong>difference</strong> of the quantity of interest on each level (or index).</li><li><code>T::Dict{::Index, ::Real}</code>: a <code>Dict</code> with the measured computation time for a sample of the quantity of interest on each level (or index).</li><li><code>W::Dict{::Index, ::Real}</code>: a <code>Dict</code> with the computational cost for a sample of the quantity of interest on each level (or index). <em>Only available when a cost model was provided!</em></li><li><code>α::Tuple</code>: the estimated rates of decay of the expected value of the difference of the quantity of interest.</li><li><code>β::Tuple</code>: the estimated rates of decay of the variance of the difference of the quantity of interest.</li><li><code>γ::Tuple</code>: the estimated rates of increase of the cost of the difference of the quantity of interest.</li><li><code>nb_of_samples::Array</code>: an <code>Array</code> with, on each index, the number of samples taken on that index. </li><li><code>logbook</code>: a logbook with information about the adaptive algorithm <em>Only available for <code>Estimator</code>s with index sets of type <code>AD</code></em></li><li><code>samples::Array</code>: an <code>Array</code> with on each index, the collection of samples of the quantity of interest taken on that index. <em>Only available when the optional key <code>save_samples = true</code> was used</em> </li><li><code>samples_diff::Array</code>: an <code>Array</code> with on each index, the collection of samples of the <strong>difference</strong> of the quantity of interest taken on that index. <em>Only available when the optional key <code>save_samples = true</code> was used</em> </li></ul><p>See also: <a href="manual.html#MultilevelEstimators.Estimator"><code>Estimator</code></a>, <a href="manual.html#Base.run"><code>run</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PieterjanRobbe/MultilevelEstimators.jl/blob/d1a19b6a08d04532cab328cf9141cb83d9029493/src/history.jl#L9-L48">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="example.html">« Example</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 12 February 2021 10:43">Friday 12 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
